# .github/workflows/main.yml

name: ML Infrastructure CI/CD Pipeline

# 定义触发条件
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  PYTHON_VERSION: '3.9'
  # 定义镜像仓库地址为GitHub Container Registry
  DOCKER_REGISTRY: ghcr.io
  # 镜像名将是 ghcr.io/<你的GitHub用户名>/<你的仓库名>
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 第一个任务：代码质量分析
  code-quality:
    name: Code Quality Analysis
    runs-on: ubuntu-latest
    steps:
      # 步骤1：检出代码，让工作流可以访问你的仓库代码
      - name: Checkout Code
        uses: actions/checkout@v4

      # 步骤2：设置指定版本的Python环境
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # 步骤3：安装项目依赖
      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          # 为了运行flake8等工具，我们可能需要开发依赖
          # 暂时先安装与主依赖相同的文件
          pip install flake8 black bandit

      # 步骤4：检查代码格式
      - name: Code Formatting
        run: |
          black --check --diff src/
          
      # 步骤5：代码风格检查 (Linter)
      - name: Linting
        run: |
          flake8 src/ --max-line-length=88

      # 步骤6：安全扫描
      - name: Security Scanning
        run: |
          bandit -r src/
  
  testing:
    name: Comprehensive Testing
    runs-on: ubuntu-latest
    # 表示这个任务必须等待 code-quality 成功后才能开始
    needs: code-quality
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Install Dependencies
        run: |
          pip install -r requirements.txt
          # 安装测试所需要的库
          pip install pytest httpx
      - name: Run Unit & Integration Tests
        run: |
          export PYTHONPATH=.
          pytest tests/

  infrastructure-validation:
    name: Infrastructure Validation
    runs-on: ubuntu-latest
    needs: [code-quality]
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v2
      - name: Terraform Format Check
        run: terraform fmt -check -recursive infrastructure/terraform/
      
      # 新增的步骤：安装并使用 kubeval
      - name: Install kubeval
        run: |
          # 下载 kubeval 二进制文件
          wget https://github.com/instrumenta/kubeval/releases/latest/download/kubeval-linux-amd64.tar.gz
          # 解压
          tar -xf kubeval-linux-amd64.tar.gz
          # 移动到可执行路径
          sudo mv kubeval /usr/local/bin

      - name: Kubernetes Manifest Validation with kubeval
        run: kubeval --ignore-missing-schemas kubernetes/*.yaml

  build-and-push:
    name: Build and Push Container
    runs-on: ubuntu-latest
    # 等待测试和基建验证都通过
    needs: [testing, infrastructure-validation]
    # 只在主分支上运行
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and Push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # .github/workflows/main.yml

  deploy:
    name: Deploy to Kind
    runs-on: self-hosted
    needs: build-and-push
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure kubectl
        id: setup_kubeconfig
        run: |
          echo "--- Writing KUBE_CONFIG secret to file ---"
          echo "${{ secrets.KUBE_CONFIG }}" > kubeconfig.yaml
          echo "path=kubeconfig.yaml" >> $GITHUB_OUTPUT

      - name: DEBUGGING STEP
        env:
          KUBECONFIG: ${{ steps.setup_kubeconfig.outputs.path }}
        run: |
          echo "--- START DEBUGGING RUNNER STATE ---"
          echo " "
          echo "1. Current directory contents:"
          ls -la
          echo " "
          
          echo "2. Content of our generated kubeconfig.yaml:"
          cat kubeconfig.yaml
          echo " "

          echo "3. Checking the KUBECONFIG environment variable:"
          echo "The KUBECONFIG variable is set to: '$KUBECONFIG'"
          echo " "

          echo "4. Checking default ~/.kube/config if it exists:"
          if [ -f "$HOME/.kube/config" ]; then
            echo "Default ~/.kube/config FOUND. Content is:"
            cat $HOME/.kube/config
          else
            echo "Default ~/.kube/config NOT FOUND."
          fi
          echo " "

          echo "5. Verifying kubectl connection with explicit config:"
          kubectl --kubeconfig=kubeconfig.yaml cluster-info
          echo " "
          echo "--- END OF DEBUGGING ---"

      - name: Deploy Application
        env:
          KUBECONFIG: ${{ steps.setup_kubeconfig.outputs.path }}
        run: |
          echo "--- Starting deployment ---"
          IMAGE_TAG="${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}@${{ github.sha }}"
          
          kubectl set image deployment/ml-api-deployment \
            ml-api-container=${IMAGE_TAG} \
            -n ml-production
          
          kubectl rollout status deployment/ml-api-deployment -n ml-production